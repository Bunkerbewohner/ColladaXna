//--------------------------------------------------------------------------------
// Shader Generic-AcEcNdOpPhongSmSpTx, generated by EffectCode at 08.08.2011 01:22:22
//--------------------------------------------------------------------------------
float4x4 World : WORLD;
float4x4 WorldIT : WORLDINVERSETRANSPOSE;
shared float4x4 View : VIEW;
shared float4x4 Projection : PROJECTION;
shared float3 EyePosition : CAMERAPOSITION; 
//--------------------------------------------------------------------------------
// Shader Parameters - Material
//-------------------------------------------------------------------------------
float3 EmissiveColor = float3(0,0,0);
float3 AmbientColor = float3(0,0,0);
Texture DiffuseMap;
Texture SpecularMap;
float SpecularPower = 0.75;
float Opacity = 1;
Texture NormalMap;
float3 DirLight1Color = float3(1, 1, 0.9019608);
float3 DirLight1Direction = float3(0, -0.5144958, 0.8574929);
float3 DirLight2Color = float3(0.2980392, 0.2980392, 0.4);
float3 DirLight2Direction = float3(-0.7071068, 0.7071068, 0);
float3 DirLight3Color = float3(0.1019608, 0.1019608, 0.1019608);
float3 DirLight3Direction = float3(0, 0, -1);
float3 AmbientLightColor = float3(0.2, 0.2, 0.2);
//--------------------------------------------------------------------------------
// Texture Samplers
//--------------------------------------------------------------------------------
sampler DiffuseMapSampler = sampler_state
{
    texture = <DiffuseMap>;
    magfilter = LINEAR;
    minfilter = LINEAR;
    mipfilter = LINEAR;
    AddressU = wrap;
    AddressV = wrap;
};
sampler SpecularMapSampler = sampler_state
{
    texture = <SpecularMap>;
    magfilter = LINEAR;
    minfilter = LINEAR;
    mipfilter = LINEAR;
    AddressU = wrap;
    AddressV = wrap;
};
sampler NormalMapSampler = sampler_state
{
    texture = <NormalMap>;
    magfilter = LINEAR;
    minfilter = LINEAR;
    mipfilter = LINEAR;
};
struct VertexShaderInput
{
	float4 Position : POSITION;
	float2 TexCoord : TEXCOORD0;
	float3 Normal : NORMAL;
	float3 Tangent : TANGENT;
};
struct VertexShaderOutput
{
	float2 TexCoord : TEXCOORD0;
	float4 PositionPS : POSITION; // Position in Projection Space
	float4 PositionWS : TEXCOORD1; // Position in World Space
	float3 Normal : NORMAL;
	float3 DirLight1DirT : TEXCOORD2;
	float3 DirLight2DirT : TEXCOORD3;
	float3 DirLight3DirT : TEXCOORD4;
};
struct PixelShaderInput
{
	float2 TexCoord : TEXCOORD0;
	float4 PositionWS : TEXCOORD1; // Position in World Space
	float3 Normal : NORMAL;
	float3 DirLight1DirT : TEXCOORD2;
	float3 DirLight2DirT : TEXCOORD3;
	float3 DirLight3DirT : TEXCOORD4;
};

VertexShaderOutput VertexShaderFunction(VertexShaderInput vin)
{
	VertexShaderOutput output;
	float4 pos_ws = mul(vin.Position, World);
	float4 pos_vs = mul(pos_ws, View);
	float4 pos_ps = mul(pos_vs, Projection);
	output.PositionPS = pos_ps;
	output.PositionWS = pos_ws;
	output.Normal = normalize(mul(vin.Normal.xyz, (float3x3)WorldIT));

	float3 Binormal = cross(vin.Tangent, vin.Normal);
	float3x3 tangentToObject;
	tangentToObject[0] = normalize(Binormal);
	tangentToObject[1] = normalize(vin.Tangent);
	tangentToObject[2] = normalize(vin.Normal);
	float3x3 tangentToWorld = mul(tangentToObject, World);

	output.DirLight1DirT = mul(tangentToWorld, DirLight1Direction);
	output.DirLight2DirT = mul(tangentToWorld, DirLight2Direction);
	output.DirLight3DirT = mul(tangentToWorld, DirLight3Direction);
	output.TexCoord = vin.TexCoord;
	return output;
};

float4 PixelShaderFunction(PixelShaderInput pin) : COLOR
{
	float4 bump = tex2D(NormalMapSampler, pin.TexCoord);
	float3 normalT = normalize((bump.xyz - 0.5f) * 2.0f);
	float3 diffuse = AmbientColor;
	float3 specular = 0;
	float3 posToEye = EyePosition - pin.PositionWS.xyz;
	float3 N = normalize(normalT);
	float3 E = normalize(posToEye);
	diffuse *= AmbientLightColor;

	float3 L;
	float3 H;
	float dt;


	// Directional Light: DirLight1
	L = -normalize(pin.DirLight1DirT);
	dt = max(0,dot(L,N));
	diffuse += DirLight1Color * dt;
	if (dt != 0)
		specular += DirLight1Color * tex2D(SpecularMapSampler, pin.TexCoord) * pow(max(0.00001f,(2 * dot(L,N) * dot(N,E) - dot(E,L))), SpecularPower);

	// Directional Light: DirLight2
	L = -normalize(pin.DirLight2DirT);
	dt = max(0,dot(L,N));
	diffuse += DirLight2Color * dt;
	if (dt != 0)
		specular += DirLight2Color * tex2D(SpecularMapSampler, pin.TexCoord) * pow(max(0.00001f,(2 * dot(L,N) * dot(N,E) - dot(E,L))), SpecularPower);

	// Directional Light: DirLight3
	L = -normalize(pin.DirLight3DirT);
	dt = max(0,dot(L,N));
	diffuse += DirLight3Color * dt;
	if (dt != 0)
		specular += DirLight3Color * tex2D(SpecularMapSampler, pin.TexCoord) * pow(max(0.00001f,(2 * dot(L,N) * dot(N,E) - dot(E,L))), SpecularPower);
	diffuse += EmissiveColor;
	float4 finalDiffuse = tex2D(DiffuseMapSampler, pin.TexCoord) * 	float4(diffuse, 1);
	finalDiffuse.a = Opacity;
	float4 color = finalDiffuse + float4(specular, 0);
	return color;
}

technique BaseTechnique
{
    pass P0
    {
        VertexShader = compile vs_3_0 VertexShaderFunction();
        PixelShader = compile ps_3_0 PixelShaderFunction();
    }
}
